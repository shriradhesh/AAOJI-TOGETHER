


const userRespondToInvitedEvent = async (req, res) => {
                            try {
                              const invitedId = req.params.invitedId;
                              const { response, selectedVenueNames, phone_no } = req.body;

                              // Check if the event exists
                              const invitedEvent = await InvitedeventModel.findById(invitedId);

                              if (!invitedEvent) {
                                return res.status(400).json({
                                  success: false,
                                  eventMessage: 'Event not found',
                                });
                              }
                                    
                              // Check if the user is a guest in the specified event
                              const guestWithMatchingPhone = invitedEvent.Guests.find(guest => guest.phone_no === phone_no);

                              if (!guestWithMatchingPhone) {
                                return res.status(400).json({
                                  success: false,
                                  eventMessage: 'User is not a guest in this event',
                                });
                              }

                              // Now check if the user exists in userModel using the provided phone_no
                              const user = await userModel.findOne({ phone_no });

                              if (!user) {
                                return res.status(400).json({
                                  success: false,
                                  userExistanceMessage: 'User not found in user table',
                                });
                              }

                              // Check if it's a single event or multiple events
                              if (invitedEvent.venue_Date_and_time.length === 1) {
                                // Single Event Logic
                                const responseMapping = {
                                  yes: 'accept',
                                  no: 'reject',
                                  maybe: 'undecided',
                                };

                                const venueStatus = responseMapping[response] === 'accept' ? 1 : responseMapping[response] === 'reject' ? 2 : 0;

                                // Update the guest's status based on the response
                                const guestToUpdate = invitedEvent.Guests.find(guest => guest.phone_no === user.phone_no);
                                guestToUpdate.guest_status = responseMapping[response] === 'accept' ? 0 : responseMapping[response] === 'reject' ? 1 : 0;
                                guestToUpdate.venue = selectedVenueNames.map((venueName, index) => ({
                                  venue_Name: venueName,
                                  venue_status: venueStatus,
                                }));

                                // Save the updated event
                                await invitedEvent.save();

                                // Save the response in the userResponseEvent table
                                const userResponse = new userResponseEventModel({
                                  hostId: invitedEvent.hostId,
                                  hostName: invitedEvent.hostName,
                                  InvitedEventId: invitedEvent._id,
                                  event_title: invitedEvent.event_title,
                                  event_description: invitedEvent.event_description,
                                  event_Type: invitedEvent.event_Type,
                                  Guests: [
                                    {
                                      Guest_Name: user.fullName,
                                      phone_no: user.phone_no,
                                      guest_status: responseMapping[response] === 'accept' ? 0 : responseMapping[response] === 'reject' ? 1 : 0,
                                      venue: selectedVenueNames.map((venueName, index) => ({
                                        venue_Name: venueName,
                                        venue_status: venueStatus,
                                      })),
                                    },
                                  ],
                                  images: invitedEvent.images,
                                });

                                await userResponse.save();

                                return res.status(200).json({
                                  success: true,
                                  responseMessage: 'Event response saved successfully',
                                });
                              } else {
                                // Multiple Events Logic
                                const responseMapping = {
                                  yes: 'accept-all',
                                  some: 'accept-some',
                                  no: 'reject',
                                };

                                let selectedVenueNamesForMultipleEvents = [];

                                if (responseMapping[response] === 'accept-some') {
                                  selectedVenueNamesForMultipleEvents = selectedVenueNames || [];
                                }

                                const userResponses = invitedEvent.venue_Date_and_time.map(dateTime => {
                                  const venueStatus =
                                    responseMapping[response] === 'accept-all'
                                      ? 1
                                      : responseMapping[response] === 'reject'
                                      ? 2
                                      : responseMapping[response] === 'accept-some' && selectedVenueNamesForMultipleEvents.includes(dateTime.venue_Name)
                                      ? 1
                                      : 0;

                                  return {
                                    hostId: invitedEvent.hostId,
                                    hostName: invitedEvent.hostName,
                                    InvitedEventId: invitedEvent._id,
                                    event_title: invitedEvent.event_title,
                                    event_description: invitedEvent.event_description,
                                    event_Type: invitedEvent.event_Type,
                                    Guests: [
                                      {
                                        Guest_Name: user.fullName,
                                        phone_no: user.phone_no,
                                        guest_status: venueStatus === 1 ? 0 : venueStatus === 2 ? 1 : 0,
                                        venue: selectedVenueNames.map((venueName, index) => ({
                                          venue_Name: venueName,
                                          venue_status: venueStatus,
                                        })),
                                      },
                                    ],
                                  };
                                });

                                  // Save each response individually
                            await userResponseEventModel.create(userResponses);

                            // Update the original event's Guests array based on the responses
                            invitedEvent.Guests.forEach(guest => {
                              const guestToUpdate = userResponses.find(response => response.Guests[0].phone_no === guest.phone_no);
                              if (guestToUpdate) {
                                guest.guest_status = guestToUpdate.Guests[0].guest_status;
                                guest.venue = guestToUpdate.Guests[0].venue;
                              }
                            });

                            // Save the updated event
                            await invitedEvent.save();

                            return res.status(200).json({
                              success: true,
                              responseMessage: 'Event responses saved successfully',
                            });
                          }
                        } catch (error) {
                          console.error(error);
                          return res.status(500).json({
                            success: false,
                            serverErrorMessage: 'Server Error',
                          });
                        }
                      };




***********************************************************

const userRespondToInvitedEvent = async (req, res) => {
  try {
    const invitedId = req.params.invitedId;
    const { response, selectedVenueNames, phone_no } = req.body;

    // Check if the event exists
    const invitedEvent = await InvitedeventModel.findById(invitedId);

    if (!invitedEvent) {
      return res.status(400).json({
        success: false,
        eventMessage: 'Event not found',
      });
    }

    // Now check if the user exists in userModel using the provided phone_no
    const user = await userModel.findOne({ phone_no });

    if (!user) {
      return res.status(400).json({
        success: false,
        userExistanceMessage: 'User not found in user table',
      });
    }

    // Create a single response record for the entire event
    const responseMapping = {
      yes: 'accept',
      no: 'reject',
      maybe: 'undecided',
      'yes-multiple': 'accept-all',
      'some-multiple': 'accept-some',
      'no-multiple': 'reject',
    };

    const venueStatus = responseMapping[response] === 'accept' ? 1 : responseMapping[response] === 'reject' ? 2 : 0;

    // Check if there is an existing record in userResponseEventModel for the same invitedId
    const existingUserResponse = await userResponseEventModel.findOne({
      InvitedEventId: invitedEvent._id,
    });

    if (existingUserResponse) {
      // Update the existing record
      existingUserResponse.Guests.push({
        Guest_Name: user.fullName,
        phone_no: user.phone_no,
        guest_status: responseMapping[response] === 'accept' ? 0 : responseMapping[response] === 'reject' ? 1 : 0,
        venue: selectedVenueNames.map((venueName, index) => ({
          venue_Name: venueName,
          venue_status: venueStatus,
        })),
      });

      // Save the updated record
      await existingUserResponse.save();
    } else {
      // Create a new record if it doesn't exist
      const newUserResponse = new userResponseEventModel({
        hostId: invitedEvent.hostId,
        hostName: invitedEvent.hostName,
        InvitedEventId: invitedEvent._id,
        event_title: invitedEvent.event_title,
        event_description: invitedEvent.event_description,
        event_Type: invitedEvent.event_Type,
        Guests: [
          {
            Guest_Name: user.fullName,
            phone_no: user.phone_no,
            guest_status: responseMapping[response] === 'accept' ? 0 : responseMapping[response] === 'reject' ? 1 : 0,
            venue: selectedVenueNames.map((venueName, index) => ({
              venue_Name: venueName,
              venue_status: venueStatus,
            })),
          },
        ],
        images: invitedEvent.images,
      });

      // Save the new record
      await newUserResponse.save();
    }

    return res.status(200).json({
      success: true,
      responseMessage: 'Event response saved successfully',
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({
      success: false,
      serverErrorMessage: 'Server Error',
    });
  }
};





********************



       const sendInvitation = async (req, res) => {
                        try {
                            const { eventId } = req.params;
                    
                            // Find event
                            const event = await eventModel.findOne({ _id: eventId }).populate('Guests');
                            if (!event) {
                                return res.status(400).json({
                                    success: false,
                                    eventExistanceMessage: 'Event not found',
                                });
                            }
                           
                        // Check for bus number
                        const existInvitedEvent = await InvitedeventModel.findOne({ eventId });
                
                        if (existInvitedEvent) {
                            return res.status(400).json({ success : true , message: 'you already invite Guests for these event ' });
                        }
                            // Create invitations object
                            const invitation = {
                                hostId: event.userId,
                                eventId: eventId,
                                hostName: event.userName,
                                event_title: event.title,
                                event_description: event.description,
                                event_Type: event.event_Type,
                                co_hosts: event.co_hosts,
                                Guests: event.Guests,
                                images: event.images,
                                event_status: event.event_status,
                                venue_Date_and_time: event.venue_Date_and_time,
                                event_status: InvitedeventModel.schema.path('event_status').getDefault(),
                            };
                    
                            // Populate Guests array with default status
                            invitation.Guests = event.Guests.map(guest => ({
                                Guest_Name: guest.Guest_Name,
                                phone_no: guest.phone_no,
                                status: 2, // Default status: 2 (pending)
                            }));
                    
                            // Save invitation to the database
                            await InvitedeventModel.create(invitation);
                    
                            for (const guest of event.Guests) {
                                // Convert the phone number string to numeric format
                                const phone_no_numeric = parseInt(guest.phone_no, 10);
                                const formattedPhoneNumber = `+91${phone_no_numeric}`;
                                const  message = `Hello, you are invited to ${event.title} by ${event.userName}. Receive updates about the event on the link: https://localhost.com`;
                               
                    
                                // Use SMS Gateway Hub to send SMS
                                await sendSMSUsingGatewayHub(formattedPhoneNumber, message);
                            }
                    
                            res.status(200).json({
                                success: true,
                                successMessage: 'Invitation for the event stored successfully, and SMS sent to guests!',
                            });
                        } catch (error) {
                            console.error('Error:', error.response ? error.response.data : error.message);
                            res.status(500).json({
                                success: false,
                                serverErrorMessage: 'SERVER ERROR',
                            });
                        }
                    };
                    
                    const sendSMSUsingGatewayHub = async (formattedPhoneNumber, message, apiKey = 'DfRvyBzYh02aalLlL4j9Zg', senderId = 'FESSMS') => {
                      const gatewayHubApiUrl = 'https://www.smsgatewayhub.com/api/mt/SendSMS';
                  
                      try {
                          // const encodedMessage = encodeURIComponent(message);
                  
                          const response = await axios.get(gatewayHubApiUrl, {
                              headers: {
                                  'Content-Type': 'application/x-www-form-urlencoded',
                              },
                              params: {
                                  APIKey: apiKey,
                                  senderid: senderId,
                                  channel: 2,
                                  DCS: 0,
                                  flashsms: 0,
                                  number: formattedPhoneNumber,
                                  text: message,
                                  route: 31,
                                  EntityId: '1111111111111111111',
                                  dlttemplateid: '1111111111111111111',
                                  TelemarketerId: 123,
                              },
                          });
                  
                          console.log('SMS sent successfully:', response.data);
                      } catch (error) {
                          console.error('Error sending SMS:', error.response ? error.response.data : error.message);
                          throw error;
                      }
                  };             
                  





{
    "sub_event_title": "haldi",
    "venue_Name": "taj hotel",
    "venue_location ": "coloba , mumbai",
    "date": "2024-02-13",
    "start_time": "10:00:00",
    "end_time": "13:00:00"
  },
  {
    "sub_event_title": "mehndi",
    "venue_Name": "taj hotel",
    "venue_location": "coloba , mumbai",
    "date": "2024-02-13",
    "start_time": "14:00:00",
    "end_time": "15:00:00"
  },
  {
    "sub_event_title": "sangeet",
    "venue_Name": "taj hotel",
    "venue_location": "coloba , mumbai",
    "date": "2024-02-14",
    "start_time": "18:00:00",
    "end_time": "22:00:00"
  }

 
****************************************************


const addImages_in_Album = async (req, res) => {
  try {
    const album_id = req.params.album_id;
    const image_arrayId = req.params.image_arrayId;

    // Check for album id and image array id
    if (!album_id) {
      return res.status(400).json({
        success: false,
        albumIdRequired: 'Album Id Required',
      });
    }

    if (!image_arrayId) {
      return res.status(400).json({
        success: false,
        imageArrayIdRequired: 'Image Array Id Required',
      });
    }

    // Check for album existence
    const album = await eventImageModel.findOne({ _id: album_id });
    if (!album) {
      return res.status(400).json({
        success: false,
        albumNotFound: 'Album not found',
      });
    }

    // Find the specified image array within the album
    const imageArray = album.images.id(image_arrayId);
    if (!imageArray) {
      return res.status(400).json({
        success: false,
        imageArrayNotFound: 'Image Array not found in the specified album',
      });
    }

    // Process and store multiple image files
    const imagePaths = [];
    if (req.files && req.files.length > 0) {
      req.files.forEach(file => {
        imagePaths.push(file.filename);
      });
    }

    // Add image paths to the image_entries array
    imageArray.image_entries.push(...imagePaths);

    // Save the changes to the album
    const updatedAlbum = await album.save();

    return res.status(200).json({
      success: true,
      message: 'Images added to the album successfully',
      updated_album: updatedAlbum,
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({
      success: false,
      serverErrorMessage: 'Server Error',
    });
  }
};


*******************************************


const deleteImage = async (req, res) => {
    try {
        const { image_id, album_id } = req.query;

        // Check required fields
        if (!image_id) {
            return res.status(400).json({
                success: false,
                image_id_Required: 'Image id required',
            });
        }

        if (!album_id) {
            return res.status(400).json({
                success: false,
                album_id_Required: 'Album id required',
            });
        }

        // Check for album
        const album = await eventImageModel.findOne({ _id: album_id });

        if (!album) {
            return res.status(400).json({
                success: false,
                album_required: 'Album not exist',
            });
        }

        // Check for image in any image array within the album
        let imageFound = false;

        album.images.forEach(imageArray => {
            const imageIndex = imageArray.image_entries.findIndex(entry => entry._id.toString() === image_id);

            if (imageIndex !== -1) {
                // Remove the image with the specified image_id from the image_entries array
                imageArray.image_entries.splice(imageIndex, 1);
                imageFound = true;
            }
        });

        if (!imageFound) {
            return res.status(400).json({
                success: false,
                image_required: 'Image not found in any image array in the album',
            });
        }

        await album.save();

        return res.status(200).json({
            success: true,
            successMessage: 'Image deleted successfully',
        });
    } catch (error) {
        console.error(error);
        return res.status(500).json({
            success: false,
            serverErrorMessage: 'Server Error',
        });
    }
};



*******************************************************

router.post('/toggle-like/:feedId/:userId', async (req, res) => {
  try {
    const { feedId, userId } = req.params;

    // Check if feedId and userId are provided
    if (!feedId || !userId) {
      return res.status(400).json({
        success: false,
        message: 'FeedId and UserId are required',
      });
    }

    // Check if the feed exists
    const feed = await eventFeedModel.findById(feedId);
    if (!feed) {
      return res.status(404).json({
        success: false,
        message: 'Feed not found',
      });
    }

    // Check if the user exists
    const user = await userModel.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }

    // Check if the user has already liked the feed
    const likedIndex = feed.feed_review.likes.indexOf(userId);
    if (likedIndex !== -1) {
      // User has already liked, so unlike
      feed.feed_review.likes.splice(likedIndex, 1);
    } else {
      // User has not liked, so like
      feed.feed_review.likes.push(userId);
    }

    // Save the updated feed
    await feed.save();

    return res.status(200).json({
      success: true,
      message: 'Toggle like/unlike successful',
      isLiked: likedIndex === -1, // Indicates whether the user has liked or unliked
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({
      success: false,
      message: 'Server error',
    });
  }
});

********************************************************


// Inside your routes or controller file
const viewFeed = async (req, res) => {
  try {
    const { feed_Id, userId } = req.params;

    // check for feed_id required
    if (!feed_Id) {
      return res.status(400).json({
        success: false,
        message: 'Feed Id required',
      });
    }

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'User Id required',
      });
    }

    // check for feed
    const feed = await eventFeedModel.findOne({ _id: feed_Id });

    if (!feed) {
      return res.status(404).json({
        success: false,
        message: 'Feed not exist',
      });
    }

    // Check if the userId has already viewed this feed
    const viewedUsers = feed.views.uniqueUsers || [];

    if (!viewedUsers.includes(userId)) {
      // Increment the view count and add userId to the viewedUsers array
      feed.feed_review.views += 1;
      feed.views.uniqueUsers = [...viewedUsers, userId];
      await feed.save();

      return res.status(200).json({
        success: true,
        message: 'View counted successfully',
        views: feed.feed_review.views,
      });
    } else {
      return res.status(200).json({
        success: false,
        message: 'User has already viewed this feed',
        views: feed.feed_review.views,
      });
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({
      success: false,
      message: 'Server error',
    });
  }
};


work on feed section of festabash ( create like , comments , and views apI

work on user section ( create user , login user , change password , update user) in sys learn 

working on mtn momo ( token generation)


